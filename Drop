const calculateBlockedAmount = (index: number) => {
    setBidData((prevBidData) => {
      const newBidData = [...prevBidData];
      const quantity = parseInt(newBidData[index].quantity, 10) || 0;

      // if price is empty, skip forcing 0
      const rawPrice = newBidData[index].price;
      const price =
        rawPrice === '' || rawPrice === null || rawPrice === undefined
          ? null
          : parseInt(rawPrice, 10);

      if (price !== null && !isNaN(price)) {
        newBidData[index].price = price.toString();
        newBidData[index].amount = (quantity * price).toFixed(2);
        newBidData[index].formattedPrice = price.toFixed(2);
        newBidData[index].formattedAmount = (quantity * price).toFixed(2);
      } else {
        // leave price blank and clear dependent fields
        newBidData[index].price = '';
        newBidData[index].amount = '';
        newBidData[index].formattedPrice = '';
        newBidData[index].formattedAmount = '';
      }

      const discount: number = Number(quantity * discountAmount);
      let minBidAmt: number = minimumApplicationAmt;
      let maxBidAmt: number = maximumApplicationAmt;

      let amountText = 'Application Bid Amount';
      if (miscountAllowed == 'Y') {
        amountText = 'Application Discount Bid Amount';
        minBidAmt = discountedMinimumBidPrice * minimumNoOFShares;
        maxBidAmt = discountedMaximumBidPrice * maximumNoOFShares;
        if (price !== null && !isNaN(price)) {
          const discountedAmt = String(quantity * price - discount);
          newBidData[index].discountedAmount = parseFloat(discountedAmt).toFixed(2);
        } else {
          newBidData[index].discountedAmount = '';
        }
      }

      let maxPriceRow: any = [];
      let maxAmount: any = '';
      if (miscountAllowed == 'Y') {
        maxAmount = Math.max(
          ...newBidData
            .map((bid: any) => Number(bid.discountedAmount))
            .filter((val) => !isNaN(val)),
        );
        maxPriceRow = newBidData.filter((bid) => Number(bid.discountedAmount) === maxAmount);
      } else {
        maxAmount = Math.max(
          ...newBidData.map((bid: any) => Number(bid.amount)).filter((val) => !isNaN(val)),
        );
        maxPriceRow = newBidData.filter((bid) => Number(bid.amount) === maxAmount);
      }

      if (maxAmount && quantity > 0) {
        const error = !(maxAmount > 0 && maxAmount >= minBidAmt && maxAmount <= maxBidAmt)
          ? `${amountText} must be between ₹${minBidAmt} and ₹${maxBidAmt}`
          : '';

        newBidData[index] = {
          ...newBidData[index],
          [`bidAmountError`]: error,
        };
      }

      setMaxBidAmount(maxAmount);
      setMaxBiddetailsRow({ ...maxPriceRow[0], maxBidValue: maxAmount?.toFixed(2) });
      return newBidData;
    });
  };
